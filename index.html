<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rock Paper Scissors AI - Switch Camera</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: white;
            text-align: center;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 { margin-top: 20px; color: #00ffcc; text-shadow: 0 0 10px rgba(0,255,204,0.5); }

        /* Controls Area */
        .controls {
            margin: 15px 0;
            background: #333;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        select {
            padding: 8px;
            border-radius: 5px;
            border: none;
            background: #555;
            color: white;
            font-size: 16px;
            max-width: 150px;
        }

        button {
            padding: 10px 25px;
            font-size: 16px;
            cursor: pointer;
            background: #00ffcc;
            color: #000;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            transition: transform 0.1s;
        }
        button:hover { transform: scale(1.05); background: #00e6b8; }
        button:disabled { background: #555; cursor: not-allowed; color: #888; }

        #switchCameraBtn {
            padding: 10px 15px;
            background: #ff00cc;
            color: white;
            display: none;
        }

        /* Game Area */
        #canvas-wrapper {
            position: relative;
            margin: 20px auto;
            border: 4px solid #00ffcc;
            border-radius: 10px;
            overflow: hidden;
            width: 224px;
            height: 224px;
            background: #000;
        }

        /* FIX: We move the video OFF-SCREEN instead of making it invisible.
           Browsers pause invisible videos. Moving it off-screen keeps it running.
        */
        #webcam-video { 
            position: absolute; 
            left: -9999px;
            top: 0;
            width: 640px; 
            height: 480px; 
        }
        
        #prediction-canvas { width: 100%; height: 100%; object-fit: cover; }

        /* UI Text */
        #status-label { font-size: 24px; font-weight: bold; margin: 10px 0; min-height: 30px; }
        #game-result { font-size: 28px; font-weight: bold; color: #ffeb3b; margin-top: 10px; min-height: 40px; }
        
        .score-board {
            display: flex;
            gap: 20px;
            font-size: 20px;
            margin-top: 20px;
            background: #222;
            padding: 10px 30px;
            border-radius: 20px;
        }
    </style>
</head>
<body>

    <h1>Rock Paper Scissors AI</h1>

    <div class="controls">
        <label for="cameraSelect">Camera: </label>
        <select id="cameraSelect" disabled></select>
        <button id="switchCameraBtn" onclick="toggleCamera()">üîÑ</button>
        <button id="startBtn" onclick="init()">Start Game</button>
    </div>

    <div id="canvas-wrapper">
        <canvas id="prediction-canvas" width="224" height="224"></canvas>
    </div>

    <!-- Video element hidden off-screen -->
    <video id="webcam-video" playsinline autoplay muted></video>

    <div id="status-label">Waiting to start...</div>
    <div id="game-result"></div>

    <div class="score-board">
        <span id="player-score">Player: 0</span>
        <span id="bot-score">Bot: 0</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

    <script>
        // --- CONFIGURATION: REPLACE THIS WITH YOUR MODEL URL ---
        const URL = "https://teachablemachine.withgoogle.com/models/Z56Hobds2/";

        let model, maxPredictions;
        let videoElement, canvas, ctx;
        let currentStream = null;
        let gameState = "IDLE";
        let lastMove = "Nothing";
        let scores = { player: 0, bot: 0 };

        async function init() {
            const startBtn = document.getElementById("startBtn");
            startBtn.innerText = "Loading...";
            startBtn.disabled = true;

            // Warn for file:// protocol
            if (window.location.protocol === 'file:') {
                alert("‚ö†Ô∏è PLEASE RUN ON LOCALHOST OR HTTPS. Cameras are blocked on file://");
            }

            try {
                // 1. Setup DOM Elements
                videoElement = document.getElementById("webcam-video");
                canvas = document.getElementById("prediction-canvas");
                ctx = canvas.getContext("2d");

                // Draw loading text
                ctx.fillStyle = "#333";
                ctx.fillRect(0,0,224,224);
                ctx.fillStyle = "#fff";
                ctx.font = "20px Arial";
                ctx.fillText("Loading Model...", 40, 110);

                // 2. Load Model
                const modelURL = URL + "model.json";
                const metadataURL = URL + "metadata.json";
                model = await tmImage.load(modelURL, metadataURL);
                maxPredictions = model.getTotalClasses();

                ctx.fillText("Starting Cam...", 40, 140);

                // 3. Permission & Setup
                await getCameras();
                
                // 4. Start Camera
                const cameraSelect = document.getElementById("cameraSelect");
                if (cameraSelect.options.length > 0) {
                    await startCamera(cameraSelect.value);
                } else {
                    // Try generic if listing failed
                    await startCamera(); 
                }

                // 5. Start Loop
                requestAnimationFrame(loop);
                
                // 6. UI
                document.getElementById("status-label").innerText = "Make a move!";
                startBtn.style.display = "none";
                document.getElementById("cameraSelect").disabled = false;
                
                startGameLogic();

            } catch (error) {
                console.error(error);
                alert("Error: " + error.message);
                startBtn.innerText = "Error";
            }
        }

        async function getCameras() {
            try {
                // Request permission first to get labels
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                const select = document.getElementById("cameraSelect");
                const switchBtn = document.getElementById("switchCameraBtn");
                
                select.innerHTML = ""; 
                
                videoDevices.forEach((device, index) => {
                    const option = document.createElement("option");
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${index + 1}`;
                    select.appendChild(option);
                });

                if (videoDevices.length > 1) {
                    switchBtn.style.display = "inline-block";
                }

                select.onchange = () => startCamera(select.value);

            } catch (err) {
                console.warn("Camera listing failed", err);
            }
        }

        async function toggleCamera() {
            const select = document.getElementById("cameraSelect");
            if (select.options.length < 2) return;
            select.selectedIndex = (select.selectedIndex + 1) % select.options.length;
            await startCamera(select.value);
        }

        async function startCamera(deviceId) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            // Constraints: Fallback to generic if deviceId fails
            const constraints = deviceId 
                ? { video: { deviceId: { exact: deviceId } } } 
                : { video: true };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                videoElement.srcObject = stream;
                
                // FIX: Force attributes for mobile
                videoElement.setAttribute("playsinline", true);
                videoElement.setAttribute("autoplay", true);
                videoElement.setAttribute("muted", true);

                // FIX: Explicit play promise
                await videoElement.play();

            } catch (err) {
                console.error("Camera start failed", err);
                alert("Camera failed to start: " + err.name);
            }
        }

        async function loop() {
            // Check if video is actually playing
            if (videoElement.readyState >= 2) {
                const videoSize = Math.min(videoElement.videoWidth, videoElement.videoHeight);
                const startX = (videoElement.videoWidth - videoSize) / 2;
                const startY = (videoElement.videoHeight - videoSize) / 2;

                ctx.save();
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
                ctx.drawImage(
                    videoElement,
                    startX, startY, videoSize, videoSize,
                    0, 0, canvas.width, canvas.height
                );
                ctx.restore();

                await predict();
            }
            requestAnimationFrame(loop);
        }

        async function predict() {
            if (!model) return;
            const prediction = await model.predict(canvas);
            
            let highestProb = 0;
            let bestClass = "";
            for (let i = 0; i < maxPredictions; i++) {
                if (prediction[i].probability > highestProb) {
                    highestProb = prediction[i].probability;
                    bestClass = prediction[i].className;
                }
            }
            
            if (gameState === "IDLE") {
                document.getElementById("status-label").innerText = `I see: ${bestClass} (${(highestProb*100).toFixed(0)}%)`;
            }
            lastMove = bestClass;
        }

        function startGameLogic() {
            const statusLabel = document.getElementById("status-label");
            const resultLabel = document.getElementById("game-result");
            
            setInterval(() => {
                gameState = "COUNTDOWN";
                resultLabel.innerText = "";
                let count = 3;
                statusLabel.innerText = "Get Ready...";
                
                const countTimer = setInterval(() => {
                    if(count === 3) statusLabel.innerText = "Rock...";
                    if(count === 2) statusLabel.innerText = "Paper...";
                    if(count === 1) statusLabel.innerText = "Scissors...";
                    count--;

                    if (count < 0) {
                        clearInterval(countTimer);
                        gameState = "RESULT";
                        determineWinner();
                        setTimeout(() => { gameState = "IDLE"; }, 2000);
                    }
                }, 800);
            }, 6000);
        }

        function determineWinner() {
            const resultLabel = document.getElementById("game-result");
            const computerOptions = ["Rock", "Paper", "Scissors"];
            const computerMove = computerOptions[Math.floor(Math.random() * 3)];
            const userMove = lastMove;

            document.getElementById("status-label").innerText = `You: ${userMove}  vs  Bot: ${computerMove}`;

            if (userMove === "Nothing" || userMove === "Background") {
                resultLabel.innerText = "‚ùì No Move Detected";
                resultLabel.style.color = "#aaa";
                return;
            }

            let result = "";
            if (userMove === computerMove) {
                result = "It's a Tie!";
                resultLabel.style.color = "#ffeb3b";
            } else if (
                (userMove === "Rock" && computerMove === "Scissors") ||
                (userMove === "Paper" && computerMove === "Rock") ||
                (userMove === "Scissors" && computerMove === "Paper")
            ) {
                result = "You Win! üéâ";
                resultLabel.style.color = "#00ffcc";
                scores.player++;
            } else {
                result = "Bot Wins! ü§ñ";
                resultLabel.style.color = "#ff5555";
                scores.bot++;
            }
            resultLabel.innerText = result;
            document.getElementById("player-score").innerText = `Player: ${scores.player}`;
            document.getElementById("bot-score").innerText = `Bot: ${scores.bot}`;
        }
    </script>
</body>
</html>